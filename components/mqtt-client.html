<script total>
exports.id = "mqttclient";
exports.name = "MQTT Client";
exports.icon = "ti ti-exchange";
exports.group = "MQTT";
exports.author = "Total.js | Alberto Cruz";
exports.version = "1";
exports.npm = ["mqtt"];
exports.flags = ["mqttclient"];

exports.config = {
	host: "localhost",
	port: 1883,
	secure: false
};

exports.outputs = [{ id: "output", name: "Messages" }];

exports.make = function (instance, config) {
	const mqtt = require("mqtt");
	let client;
	const subscriptions = {};

	const state = () => {
		let obj;
		if (!client) {
			obj = {
				connected: false,
				connecting: false,
				disconnected: true,
				disconnecting: false,
				status: "disconnected"
			};
		} else {
			const { connected, disconnecting, reconnecting } = client;
			obj = {
				connecting: client.stream ? client.stream.connecting : false,
				connected,
				disconnecting,
				reconnecting
			};
			const current = Object.keys(obj).filter(k => obj[k]);
			obj.status = current.length ? current[0] : "disconnected";
		}

		instance.state = { status: obj.status, name: `${config.host}:${config.port}` };
		instance.status(instance.state);
		return obj;
	};

	function disconnect(callback) {
		if (!client) return callback && callback();
		if (client.end) client.end(true, cb);
		else cb();

		function cb() {
			client.removeAllListeners();
			client = null;
			callback && callback();
		}
	}

	function connect() {
		state();
		const broker = `${config.secure ? "mqtts" : "mqtt"}://${config.host}:${config.port}`;
		config.name = `[MQTT] ${config.host}:${config.port}`;
		const opt = CLONE(config);
		delete opt.auth;
		client = mqtt.connect(broker, opt);

		client.on("connect", () => {
			state();
			notifypubsub();
		});
		client.on("reconnect", state);
		client.on("message", (topic, message) => {
			message = message.toString();
			if (message[0] === "{" || message[0] === "[")
				message = message.parseJSON(true);
			onmessage(topic, message);
		});
		client.on("close", err => {
			console.log(`${config.name} close`, err);
			state();
		});
		client.on("error", err => {
			console.log(`${config.name} error`, err);
			state();
		});
	}

	function onmessage(topic, message) {
		const ts = new Date();
		for (const sub in subscriptions) {
			const match = mqttWildcard(topic, sub);
			if (match) {
				subscriptions[sub].forEach(id => {
					const com = instance.main.find(id);
					com && com.onmessage(topic, message, match, ts);
				});
			}
		}
		instance.send("output", { topic, message, ts });
	}

	function notifypubsub() {
		const instances = instance.main.instances().filter(i =>
			i.module.flags?.includes("mqttbroker-dep") && i.config.broker === instance.id
		);
		instances.forEach(com => com.configure());
	}

	function mqttWildcard(topic, wildcard) {
		if (topic === wildcard) return [];
		if (wildcard === "#") return [topic];

		const t = String(topic).split("/");
		const w = String(wildcard).split("/");
		const res = [];

		for (let i = 0; i < t.length; i++) {
			if (w[i] === "+") {
				res.push(t[i]);
			} else if (w[i] === "#") {
				res.push(t.slice(i).join("/"));
				return res;
			} else if (w[i] !== t[i]) {
				return null;
			}
		}

		return (t.length === w.length) ? res : null;
	}

	instance.configure = () => disconnect(connect);
	instance.close = () => disconnect(notifypubsub);
	instance.publish = (topic, message, options) => {
		const data = typeof message === "string" ? message : JSON.stringify(message || {});
		client?.publish(topic, data, options, err => {
			if (err) console.log(`${config.name} publish error`, err);
		});
	};
	instance.subscribe = (id, topic) => {
		subscriptions[topic] = subscriptions[topic] || [];
		if (!subscriptions[topic].includes(id)) {
			client?.subscribe(topic);
			subscriptions[topic].push(id);
		}
	};
	instance.unsubscribe = (id, topic) => {
		const sub = subscriptions[topic];
		if (sub) {
			subscriptions[topic] = sub.filter(x => x !== id);
			if (client?.connected && subscriptions[topic].length === 0) {
				client.unsubscribe(topic);
			}
		}
	};

	instance.configure();
};
</script>
